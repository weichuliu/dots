#!/bin/bash

## git
gdifff () { git diff --color "$@" | diff-so-fancy; }
prune () {(
  set -euo pipefail

  remote_repo="${remote_repo:-origin}"
  branch_name="$(git rev-parse --abbrev-ref HEAD)"

  if [[ "${branch_name}" =~ ^(master|develop)$ ]]; then
    git_action=pull
  else
    git_action=fetch
  fi
  echo $(tput setaf 6)git $git_action $remote_repo --prune$(tput sgr0)
  git $git_action $remote_repo --prune
)}
push () {(
  set -euo pipefail

  remote_repo="${remote_repo:-origin}"
  branch_name="$(git rev-parse --abbrev-ref HEAD)"

  if [ "${1:-}" == "force" ]; then
    [[ "${branch_name}" =~ ^(master|develop)$ ]] &&
      echo "Cannot force-push to master or develop" >&2 &&
      false
    cmd="git push $remote_repo --force-with-lease"
    color_cmd="git push $remote_repo $(tput setaf 1)--force-with-lease $(tput setaf 2)$branch_name$(tput sgr0)"
  else
    cmd="git push $remote_repo"
    color_cmd="git push $remote_repo $(tput setaf 2)$branch_name$(tput sgr0)"
  fi

  echo "$color_cmd"
  read -p "[type 42 to continue] " THE_answer
  [[ "${THE_answer}" = "42" ]]
  $cmd $branch_name
)}

## subl
sf. () { f. $@ | tee >(tr '\n' '\0' | xargs -0 subl); }
snf. () { f. $@ | tee >(tr '\n' '\0' | xargs -0 subl --new-window); }
sack () { ack -l $@ | tee >(tr '\n' '\0' | xargs -0 subl); }
snack () { ack -l $@ | tee >(tr '\n' '\0' | xargs -0 subl --new-window); }
sgdiff () { git diff --name-only $@ | tee >(cd "$(git rev-parse --show-toplevel)"; tr '\n' '\0' | xargs -0 subl); }
sngdiff () { git diff --name-only $@ | tee >(cd "$(git rev-parse --show-toplevel)"; tr '\n' '\0' | xargs -0 subl --new-window); }

# awk print column
awkp () {
  awk -F "${FS:- }" -v column="$1" '{print $column}' -
}
# sum up the $1 column
sumup () {
  awk -F "${FS:- }" -v column="$1" '{a += $column} END {print a}' -
}
average () {
  awk -F "${FS:- }" -v column="$1" '{a += $column} END {print a/NR}' -
}
# Calculate delta (intervals) between rows of numbers
delta () {
  awk -F "${FS:- }" -v column="$1" 'BEGIN {last=0} {print $column-last; last=$column}' -
}
# Prefix timestamp on stdin
timestamp () {
  ruby -ne 'BEGIN{startt=Time.now; trap("SIGINT"){}}; printf "%d(%.3f) %s", Time.now, Time.now-startt, $_' -
}

# A very simple implementation of watch
watch () {
  while date >&2; do
    eval "$@"
    sleep "${sleep:-15}"
  done
}

# pbedit
pbedit () {
  # Edit clipboard using vim, then save it back
  # If stdin is pipe, use contents from stdin
  # If stdout is pipe, pbpaste to stdout
  local temporary_buffer="$(mktemp)"
  if [[ -p /dev/stdin ]]; then
    cat -
  else
    pbpaste
  fi > "$temporary_buffer"
  (
    exec < /dev/tty
    exec &> /dev/tty
    # do no modify the EOF newline
    vim -c 'set nofixendofline' "$temporary_buffer"
  )
  pbcopy < "$temporary_buffer"
  rm "$temporary_buffer"
  # If stdout is a pipe
  [[ -p /dev/stdout ]] && pbpaste
}
pbedit-subl () {
  # Edit clipboard using subl, then save it back
  # If stdin is pipe, use contents from stdin
  # If stdout is pipe, pbpaste to stdout
  if [[ -p /dev/stdin ]]; then
    cat -
  else
    pbpaste
  fi | subl - | perl -pe 'chomp if eof' | pbcopy
  # If stdout is a pipe
  [[ -p /dev/stdout ]] && pbpaste
}

# A nice hack to copy current READLINE into pasteboard
# This requires bash 4.x (/usr/local/bin/bash)
# Ref: stackoverflow.com/questions/14177700
if grep -q ^4 <<<$BASH_VERSION ; then
  __copyline () {
    printf %s "$READLINE_LINE" | pbcopy
  }
  # Bind to 'Ctrl-x' 'c' seq
  bind -x '"\C-xc":__copyline'
fi

# Himitsu ;-)
nohist () {
  unset HISTFILE
  echo  HISTFILE unset
}
