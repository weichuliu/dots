#!/bin/bash

## git
gdifff () { git diff --color "$@" | diff-so-fancy; }
prune () {(
  set -euo pipefail

  remote_repo="${remote_repo:-origin}"
  branch_name="$(git rev-parse --abbrev-ref HEAD)"

  if [[ "${branch_name}" =~ ^(master|develop)$ ]]; then
    git_action=pull
  else
    git_action=fetch
  fi
  echo $(tput setaf 6)git $git_action $remote_repo --prune$(tput sgr0)
  git $git_action $remote_repo --prune
)}
push () {(
  set -euo pipefail

  remote_repo="${remote_repo:-origin}"
  branch_name="$(git rev-parse --abbrev-ref HEAD)"

  [[ "${branch_name}" =~ ^(master|develop)$ ]] &&
    echo "Cannot push to master or develop" &&
    return 1

  if [ "${1:-}" == "force" ]; then
    cmd="git push $remote_repo --force-with-lease"
    color_cmd="git push $remote_repo $(tput setaf 1)--force-with-lease $(tput setaf 2)$branch_name$(tput sgr0)"
  else
    cmd="git push $remote_repo"
    color_cmd="git push $remote_repo $(tput setaf 2)$branch_name$(tput sgr0)"
  fi

  echo "$color_cmd"
  read -p "[type 42 to continue] " THE_answer
  [[ "${THE_answer}" = "42" ]]
  $cmd $branch_name
)}

## subl
sf. () {
  f. $@ | tee >(tr '\n' '\0' | xargs -0 subl)
}
sack () {
  ack -l $@ | tee >(tr '\n' '\0' | xargs -0 subl)
}

# awk print column
awkp () {
  awk -v column="$1" '{print $column}' -
}
# sum up the $1 column
sumup () {
  awk -v column="$1" '{a += $column} END {print a}' -
}
# Prefix timestamp on stdin
prefix-timestamp () {
  ruby -ne 'printf "%.3f %s", Time.now, $_' -
}
# Calculate delta (intervals) between rows of numbers
delta () {
  awk -v column="$1" 'BEGIN {last=0} {print $1-last; last=$1}' -
}

# pbedit
pbedit () {
  # Edit clipboard using vim, then save it back
  # If stdin is pipe, use contents from stdin
  # If stdout is pipe, pbpaste to stdout
  local temporary_buffer="$(mktemp)"
  if [[ -p /dev/stdin ]]; then
    cat -
  else
    pbpaste
  fi > "$temporary_buffer"
  (
    exec < /dev/tty
    exec &> /dev/tty
    # do no modify the EOF newline
    vim -c 'set nofixendofline' "$temporary_buffer"
  )
  pbcopy < "$temporary_buffer"
  rm "$temporary_buffer"
  # If stdout is a pipe
  [[ -p /dev/stdout ]] && pbpaste
}
pbedit-subl () {
  # Edit clipboard using subl, then save it back
  # If stdin is pipe, use contents from stdin
  # If stdout is pipe, pbpaste to stdout
  if [[ -p /dev/stdin ]]; then
    cat -
  else
    pbpaste
  fi | subl - | perl -pe 'chomp if eof' | pbcopy
  # If stdout is a pipe
  [[ -p /dev/stdout ]] && pbpaste
}

# A nice hack to copy current READLINE into pasteboard
# This requires bash 4.x (/usr/local/bin/bash)
# Ref: stackoverflow.com/questions/14177700
if grep -q ^4 <<<$BASH_VERSION ; then
  __copyline () {
    printf %s "$READLINE_LINE" | pbcopy
  }
  # Bind to 'Ctrl-x' 'c' seq
  bind -x '"\C-xc":__copyline'
fi

# Himitsu ;-)
nohist () {
  unset HISTFILE
  echo  HISTFILE unset
}
