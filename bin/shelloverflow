#!/usr/bin/env python3
# TODO: interactive questions/answers
#       more answer choice strategy
#       redirect if answer is duplicated?
#       warn on low quota
import sys
import re
import requests
import html.parser
import urllib.parse
import termcolor
from termcolor import colored
from bs4 import BeautifulSoup

# google
google_search_url = 'https://www.google.com/search?ie=UTF-8&q={}'
google_is_happy_header = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0)' # To deceive google

# returns answers from /questions/ also returns body_markdown for q+a
so_api_filter = '!b1MMEU*.-3EcYn'
so_api_url = 'https://api.stackexchange.com/2.2/questions/{}?site=stackoverflow&filter={}'


def colored_on_tty_stdout(s, color=None, on_color=None, attrs=None):
    """tty aware colored wrapper"""
    return __colored(s, color, on_color, attrs, sys.stdout.isatty())

def __colored(s, color=None, on_color=None, attrs=None, do_colorize=True):
    """a termcolor.colored wrapper. when do_colorize==False return original s"""
    if do_colorize:
        return colored(s, color, on_color, attrs)
    else:
        return s

def google_for_so_questions(query):
    google_query_url = google_search_url.format(urllib.parse.quote_plus(f'stackoverflow {query}'))
    response = requests.get(google_query_url, headers={'User-Agent': google_is_happy_header})
    if response.status_code != 200:
        print(f'Get status_code {res.status_code}!=200 when searching on google', file=sys.stderr)
        return []
    # mod from socli
    soup = BeautifulSoup(response.text, 'html.parser')
    results = soup.find_all('div', class_='g')
    #                   question url                   question title
    question_results = [(result.find("a").get("href"), re.sub(' - Stack Overflow$', '', result.find("h3", class_="r").get_text())) for result in results]
    return [q for q in question_results if extract_so_qid_from(q[0])]

def extract_so_qid_from(url):
    # TODO: support other websites. Now strict to stackoverflow
    if 'stackoverflow' in url and re.search('/(questions|q)/(\d+)', url):
        return re.search('/(questions|q)/(\d+)', url).group(2)
    else:
        None

def so_qna_in_json(qid):
    so_question_api_url = so_api_url.format(qid, so_api_filter)
    res = requests.get(so_question_api_url)
    assert res.status_code == 200, f'return code is {res.status_code} while querying {so_question_api_url}'
    return res.json()

def render_so_question_link(question_link, question_title):
    return f"{colored_on_tty_stdout(question_title, attrs=['bold'])} ({colored_on_tty_stdout(question_link, 'green')})"

def render_so_qna(contents):
    question = contents['items'][0]
    question_title = question['title']
    question_link = question['link']
    question_body = html.parser.unescape(question['body_markdown'])

    accepted_answers = [a for a in question['answers'] if a['is_accepted']]
    if any(accepted_answers):
        accepted_answer = accepted_answers[0]
    else:
        # TODO: handle empty answers
        #       sort anwser
        #       'accepted' is wrong name
        accepted_answer = question['answers'][0]
    accepted_answer_body = html.parser.unescape(accepted_answer['body_markdown'])

    # TODO: switch color/non-color in a proper way

    rendered_texts = [
        render_so_question_link(question_link, question_title),
        '',
        rendered_md_body(question_body),
        colored_on_tty_stdout('---------- Accepted Answer ----------', 'yellow', attrs=['bold']),
        rendered_md_body(accepted_answer_body),
    ]
    return '\n'.join(rendered_texts)

def rendered_md_body(body):
    # TODO
    # CAVEAT: Ok, the second highlight within highlight block will remove the effect
    #   probably time to do the real highlighting
    def __rendered_strong(m):
        return colored_on_tty_stdout(m.group(1), attrs=['bold'])
    def __rendered_code(m):
        green = colored('', 'green').replace(termcolor.RESET, '')
        return colored_on_tty_stdout(m.group(1).replace(termcolor.RESET, termcolor.RESET+green), 'green')
    def __rendered_quoted_code(m):
        return '> ' + colored_on_tty_stdout(m.group(1), 'green')
    def __rendered_quote(m):
        return colored_on_tty_stdout('> ', 'yellow')

    # strong
    body = re.sub(r'\*\*(.*?)\*\*', __rendered_strong, body, flags=re.M)
    # code
    body = re.sub(r'```(.*?)```', __rendered_code, body, flags=re.DOTALL)
    body = re.sub(r'<pre>(.*?)</pre>', __rendered_code, body, flags=re.DOTALL)
    body = re.sub(r'`(.*?)`', __rendered_code, body, flags=re.M)
    body = re.sub(r'^(    .*)$', __rendered_code, body, flags=re.M)
    # quoted_code
    body = re.sub(r'^> (    .*)$', __rendered_quoted_code, body, flags=re.M)
    # quote
    body = re.sub(r'^> ', __rendered_quote, body, flags=re.M)

    return body

def main():
    self_name = sys.argv[0].split('/')[-1]
    # when --show <qid>, directly show
    if len(sys.argv) >= 3 and sys.argv[1] == '--show':
        qid = int(sys.argv[2])
        questions = []
    else:
        query = ' '.join(sys.argv[1:])
        questions = google_for_so_questions(query)
        if questions:
            best_matched_question = questions[0]
            qid = extract_so_qid_from(best_matched_question[0])

    contents = so_qna_in_json(qid)
    print(render_so_qna(contents))

    print ('---------- Other Questions ----------')
    for q in questions[1:]:
        print(render_so_question_link(f'{self_name} --show {extract_so_qid_from(q[0])}', q[1]))

if __name__ == '__main__':
    main()
